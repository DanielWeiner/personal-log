#!/bin/bash
set -euo pipefail

log_tmp="$(mktemp /tmp/personal-log.tmp.XXXXXX)"
log_file="${PERSONAL_LOG:-$HOME/Documents/personal-log.txt}"
timestamp=
datestamp=
input_text="$*"
modified_time=

trap 'rm -f "$log_tmp"' EXIT

if [ "${1:-}" == "--uninstall" ]; then
    echo "Uninstalling personal-log..."
    if command -v pacman >/dev/null 2>&1 && pacman -Q personal-log >/dev/null 2>&1; then
        sudo pacman -R personal-log
        exit 0
    fi

    sudo rm -f /usr/local/bin/searchlog
    sudo rm -f /usr/local/bin/readlog
    sudo rm -f /etc/profile.d/personal-log-env.sh
    sudo rm -f /usr/local/bin/personal-log

    echo "personal-log uninstalled successfully."
    exit 0
fi

mkdir -p "$(dirname "$log_file")"
touch "$log_file"

# IANA timezone names give you a rough idea of where you are, even within a single timezone.
# In a personal log, you might want to remember where you were.
function get_timezone() {
    # in all cases, print the short timezone code first.
    printf '%s' "$(date +"%Z")"

    # some systems symlink /etc/localtime to the actual timezone file, like Arch
    if [ -L /etc/localtime ]; then
        printf ' | %s' "$(readlink -f /etc/localtime | sed 's|.*/zoneinfo/||')"
    # some systems have the timezone in /etc/timezone, like Debian distros
    elif [ -f /etc/timezone ]; then
        printf ' | %s' "$(cat /etc/timezone)"
    # if the above methods fail, then see if systemd can tell us
    elif command -v timedatectl >/dev/null 2>&1; then
        printf ' | %s' "$(timedatectl show -p Timezone --value)"
    # otherwise, the short timezone will have to do
    fi
}

# see https://superuser.com/questions/737247/get-last-modified-date-of-file-in-linux#comment2543695_1245986
# reportedly works on OSX, and tested to work on Arch
function get_modified_time() {
    date -r "$1" -u +"%Y-%m-%dT%H:%M:%SZ"
}

# The arguments are added as text to the beginning of the file, so that when you type 
# "personal-log I went to the zoo", it doesn't get lost.
# It felt more natural to me for the text to follow "personal-log" rather than hit enter before typing. 
# I found myself accidentally doing that in the prototype version, which did not consume the arguments as text.
echo "$input_text" > "$log_tmp"

# set the modified time to the distant past so we know if the user saved it 
TZ=UTC touch -a -m -t 197001010000 "$log_tmp" 
modified_time="$(get_modified_time "$log_tmp")"

# Vim in easy (evim) mode is more user-friendly for quick text entry.
# "normal G$ moves to the end of the pre-filled text, and "normal a " adds a space to the buffer so a quit will prompt to save
vim -c "normal G$" -c "normal a " -y "$log_tmp"

if [ "$(get_modified_time "$log_tmp")" == "$modified_time" ]; then
    echo "No log entry created." >&2
    exit 1
fi

# Don't add empty entries
if ! grep -q '[^[:space:]]' "$log_tmp"; then
    echo "No log entry created." >&2
    exit 1
fi

# Strip leading and trailing whitespace, and add a newline at the end
perl -0777 -i -pe 's/^\s+//; s/\s+$//' "$log_tmp"
printf '\n' >> "$log_tmp"

timestamp="$(date +"[%-l:%M %p | $(get_timezone)]")"
datestamp="$(date +'[[ %A, %B %d %Y ]]')"

{
    # Future optimization - search from the end, if the last date stamp is before today, no need to keep searching
    if ! grep -Fq "$datestamp" "$log_file" 2>/dev/null; then
        [ -s "$log_file" ] && printf '\n'
        printf '=== %s ===\n' "$datestamp"
    fi

    # Always output the timestamp. It's good to know what time of day you made the entry
    printf '\n%s\n' "$timestamp" 

    # Finally, the log entry itself
    cat "$log_tmp"
} | tee -a "$log_file" # and append it to the log file
exit 0
